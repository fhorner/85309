---
title: "Tutorial 1: Base R"
author: "Fiona Horner"
date: "2024-01-15"
output: 
  html_document:
    theme: journal
    toc: yes
    toc_float:
      collapsed: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

 
*Note: The content in this tutorial is based off of [Javier Rasero's](https://github.com/jrasero/cm-85309-2023) prior 309 course content. It also draws from [Data Explorations](https://coaxlab.github.io/Data-Explorations/intro.html) (85-432).*

Check out the [Base R cheatsheet](https://iqss.github.io/dss-workshops/R/Rintro/base-r-cheat-sheet.pdf) for additional background on R.

## The Basics

In R, you can do basic arithmetic just like any other programming language.
```{r}
2 + 2
```

You can assign values to variables like so:

```{r}
x <- 2 
print(x)
```

This allows you to quickly access past values and avoid having to repeat operations. Note that `<-` is a single character, known as an **assignment operator**. In this instance, you could also use `=` as an assignment operator:
```{r}
y = 7
print(y)
```

However, `=` and `<-` do not always behave the same. **It is better practice to use `<-` for assigning variables.** Inside of function calls, you typically need to use `=`.

Note that `=` is different from `==`. The first acts as an assignment operator, while the second is a logical operator that assesses equality. Logical operators in R return TRUE/FALSE. These are especially useful in conditional statements, which we'll cover soon.

The main logical operators in R are:

```{r}
# x equal to y
x==y
# x not equal to y
x!=y
# x greater that y
x>y
# x smaller that y
x<y
# x greater than or equal to y
x>=y
# x smaller than or equal to y
x<=y
```

## Useful keyboard shortcuts

Keyboard shortcuts can be very handy with R! The ones I use the most are:

* Insert new code chunk: 
  * Mac: Opt + Cmd + I
  * Windows: Ctrl + Alt + I
* Insert assignment operator `<-`
  * Mac: Opt + -
  * PC: Alt + -
* Comment out blocks of code:
  * Mac: Shift + Cmd + C
  * PC: Shift + Ctrl + C
  
You can view additional keyboard shortcuts under Tools --> Keyboard Shortcuts Help

## Data Types

R has 6 basic data types, some of which we have already skimmed over:

- **character**: e.g. "a", "hola", '4' etc. Note the quotes!
- **numeric** (real or decimal): 3, 3.1415, -10, etc.
- **integer**: 3L (The L specifies this variable to be an integer)
- **logical**: TRUE or FALSE
- **complex**: 1+2i
- **raw**: values as raw bytes (we won't be using this)

In case of doubt about the data type, R provides built-in functions to inspect this, for example, `class` and `typeof`.

```{r}
class('s')
typeof('3.1415')
class(3.1415)
```


## Data Structures

### Vectors

Vectors are lists of numbers or strings. Note the `c` prior to the parentheses. This stands for concatenate, and is necessary when defining a vector.

```{r}
a <- c(1,2,3)
b <- c(4,5,6)
a
b
```

Vector operations occur element-wise:
```{r}
a*b
a + 5
(a*2) + b
```

### Data frames

Data frames can contain data of mixed types such as numbers and strings. Usually, each column is a different variable, and items within each column are of the same type.

For this class, we'll typically be loading existing datasets as data frames. But you can also create them from scratch.

```{r}
c <- c("one", "two", "three")
data <- data.frame(aVar = a, bVar = b, cVar = c)
data
```

When loading existing datasets, you can use `str()` to quickly view information about the dimensions of the dataset and the variables included:
```{r}
str(data)
```

**A quick note on tibbles:** You will frequently see tibbles (`tbl` or `tbl_df`) used in the tidyverse. In this class we'll consider these the same as data frames, although there are some slight differences in how they work. 

## Factors

A factors is a data structure that is used for categorical data.
```{r}
genderVector <- c("male", "male", "nonbinary", "female", 
                  "male", "nonbinary", "female")
genderVector
```

```{r}
genderFactor <- as.factor(genderVector)
genderFactor
class(genderFactor[1])
```

Note that factors can be character or numeric. For example, we could code the same data as:
```{r}
genderVectorNum <- c("1", "1", "2", "3", 
                  "1", "2", "3")
genderFactor <- as.factor(genderVectorNum)
genderFactor
class(genderFactor[1])
```

This holds the exact same information: three categories of a categorical variable. The `Levels` output tells us all of the possible labels/values for the variable. 

But remember, categorical data can't be used in numeric calculations:
```{r}
mean(genderFactor)
```
And this makes sense -- the 'mean gender' of a sample doesn't make sense.

## Indexing

### Vectors
In a vector, you can index data by it's position. Note that R uses **1-based indexing**, i.e., the first value is index 1. This is contrast to other common languages like Python that use 0-based indexing (first value is index 0). 
```{r}
b[1]
```

If you want to access multiple values, use a colon. Note that this range is **inclusive**: the value at index 1 and the value at index 2 will both be included in the output.
```{r}
b[1:2]
```

To access non-contiguous values, you need to add a vector within the brackets. Note the `c`!
```{r}
b[c(1, 3)]
```

You can use indexing to reassign values in a vector:
```{r}
b
b[1] <- 7
b
```


### Data frames
In a data frame, you index by both column and row using `data[row,col]`.
```{r}
data[1, 2]
```

To get a whole row or column, you just leave out one of the two numbers. Note that you still need the comma:
```{r}
data[,2]
```

For columns, you can also call a column by it's name:
```{r}
data$bVar
```
You can also name rows in R, but it is not common. 

##### Q1: Which of these methods of calling a column (indexing versus $) do you think is better? Why?

Just like vectors, you can use indexing to change a data frame.
```{r}
data[1, 2] <- 8
data
```

```{r}
data$dVar <- c("a", "new", "col")
data
```

#### Q2: Try adding a fourth element in the above vector for `dVar`. What happens?
#### Q3: What happens if you assign a single number, instead of a vector, as a column in a data frame? 

You can create a copy of a data set (or any object) by reassigning it a new name:
```{r}
data2 <- data
data$dVar <- c('a', 'different', 'column')

head(data)
head(data2)
```

Notice that these two objects are NOT aliases of each other -- changing `data` did not change `data2`.


### Other useful data types in R include:

* Matrix: like a data frame, but all elements are of the same type. See `?matrix` and `?as.matrix`
* List: like a vector, but elements can be of different types. See `?list`

## Functions

The way calculations are done in an encapsulated way is through the use of **functions**. For example, R has the built-in functions, `sqrt` , designed to compute the square root of an input value.

```{r}
sqrt(25)
```

When we use a function to do something, we generally refer to this as **calling** the function, and the values that we type into the function (there can be more than one) are referred to as the **arguments** of that function.

R uses named arguments. For a simple call like `sqrt()`, this doesn't matter much, but it's handy for more complex functions that take many arguments. To illustrate, let's look at the function `round()`, which takes a number to be rounded as well as the number of decimals desired.

```{r}
round(3.1415, 2)
round(x = 3.1415, digits = 2)

round(digits = 2, x = 3.1415)
round(2, 3.1415)
```
##### Q4: Why does the final call produce a different result?

Many functions also use **default values**. That is, arguments that if not specified, they take a particular value. In our example, 0 is the default value for digits:

```{r}
round(3.1415)
```

There are several ways to access information about a function, its arguments, and its default values.

`str()`, which we used above to understand datasets, is also useful for quickly viewing function arguments.
```{r}
str(round)
```

More importantly, typing `?` before a function or built-in data set will bring up the full documentation for that object. This includes function arguments, as well as examples and further details about input and output requirements. This is an extremely useful tool and I encourage you to get comfortable using it!

```{r}
?round
```


### Base R: Some useful functions

These base functions may also be useful in understanding a data set.
```{r}
length(a) 
mean(a)
sum(a)
nrow(data)
ncol(data)
dim(data)
head(data, n = 2) #default value of n is 6 lines
tail(data, n = 2) #default value of n is 6 lines
names(data)
str(data)
```
## Programming Basics

At some point, in order to perform and implement complex tasks, you may end up having to write a computer program. As a consequence, it is recommended that you familiarize yourself with some basic programming operations in R.

If you've already taken a Python class, these will look familiar and you'll just want to note the differences in formatting between R and Python. If you are brand new to programming, you may want to spend some additional time understanding this section of this tutorial. And feel free to bring questions to office hours!

### A note on naming

As you create more and more complicated code, you'll need to keep track of many different named objects (e.g., variables, functions, data frames, file names, etc.) To avoid confusion and heart break, follow best practices in naming:

* Names should be descriptive: calling a variable `x` will give your future self no inclination as to what that variable captures. The name should reflect the variable's meaning. For example:
  * Yes: `postTestMath` or `post_test_math`
  * No: `x` or `foo` or `outcome`
* Use consistent naming practices. Follow similar patterns to maintain sanity. Two common approaches are camel case and snake case:
  * `thisIsCamelCase`: No underscores, first word starts with lower case and the rest of the words start with upper
  * `this_is_snake_case`: Use underscores to separate words, all lowercase.
* No weird characters: avoid characters like: $#!* etc in names (and R will crash if you try to start a name with punctuation)

### Conditional Statements

A conditional statement is an operation that allows you to switch between different possible commands depending on a specified condition that is specified by the programmer.

The most prominent example of a conditional statement is the if statement, and the accompanying else statement. 

For conditional statements, recall our logical operators that we learned above:

* "==" : Equal
* "!=" : Not equal
* ">" : Greater than
* "<" : Less than
* ">=" : Greater than or equal to
* "<=" : Less than or equal to

An additional useful operator is `%in%`, which is used to determine if a value is present in a vector.
```{r}
myVector <- c("this", "is", "my", "vector")
"this" %in% myVector #returns TRUE
"that" %in% myVector #returns FALSE
```

The basic form of an if statement in R is:

```{r, eval=FALSE}
if ( CONDITION ) {
STATEMENT1
STATEMENT2
ETC
}
```

(Bonus question: Why was this .RMD able to knit, even though the objects in this chunk have not been defined?)

For example:
```{r}
x <- 5
if(x > 4){
    print("x greater than 4")
}
```

As you can see, if the condition within the parentheses is true, then R will execute the statements contained in the curly braces. If the condition is false, then it does nothing.

If you want to perform an operation when the condition within if is not satisfied, you can extend the if statement to include an else statement as well, leading to the following syntax:

For example:
```{r}
x <- 3
if( x > 4){
    print("x greater than 4")
} else {
    print("x smaller than 4")
}
```


Finally, a handy way of applying an if/else statement to several elements in a vector is by the ifelse function:
```{r}
# input vector
x <- c(12, 9, 23, 14, 20, 1, 5)

# ifelse() function to determine odd/even numbers
# %% is the modulo, indicating the remainder after a division operation
ifelse(x %% 2 == 0, "EVEN", "ODD")
```

Remember, operations to vectors occur element-wise, which is why inputting a vector to this statement doesn't crash and gives us an output for each element in x. 

### Loops

Loops are block of codes (i.e., a sequence of commands) that will execute over and over again until some termination criterion is met.

#### While Loop

A while loop iterates **while** the condition is TRUE. Then it stops. 
```{r, eval=FALSE}
while ( CONDITION ) {
STATEMENT1
STATEMENT2
ETC
}
```

More specifically, when R encounters a while statement it checks to see if the condition within the parenthesis is TRUE. If it is, then R carries on executing all of the commands inside the curly brackets. When it gets to the bottom of those statements, it moves back up to the while statement. Then, it checks to see if the condition is TRUE. If it is, then it executes everything again. And it does so until the condition turns out to be FALSE, for which it exits the loop.

If your condition never becomes false you'll be in an infinite loop!
```{r}
x <- 0
while ( x < 100 ) {
x <- x + 17
print( x )
}
print("I exited the loop, yeah!")
```

#### For Loop

A for loop iterates **for** a certain number of iterations, usually based on other R objects.
```{r, eval=FALSE}
for ( i in OBJECT ) {
STATEMENT1
STATEMENT2
ETC
}
```

Here we iterate through a vector:
```{r}
for (i in c(1:5)) {
print(i)
}
```
Here we iterate through rows in a data frame:
```{r}
for (row in data) {
print(row)
}
```
**Practice:** Create a variable "x" and set a value 0 to it. Then, create a loop that iterates a vector from 1 to 10. In each iteration update the value of x by adding the value of each element of the vector. 

```{r}
# Write your answer here
```


### Writing Your Own Functions

We have already introduced the concept of functions and how to use them. However, we have only used predefined functions. What if we want to write our own functions? This can be helpful in case we want to perform a specific computation, and will really expand your R horizons!

The syntax that you use to create a function is as follows:
```{r, eval=FALSE}
FUNCTION_NAME <- function (ARG1, ARG2 = 10, ETC) {
STATEMENT1
STATEMENT2
ETC
return(VALUE)
}
```

This will create a function with the name FUNCTION_NAME, which has arguments arg1, arg2 and so forth. Whenever the function is called, R executes the statements in the curly braces, and then outputs the contents of value to the user. To note, only the final results in the value are returned. Everything that was set or stored within the function will no be visible after the function is called.

Note that the `= 10` after `ARG2` indicates that 10 is the default value for `ARG2`. If you don't specify `ARG2`, the function will still run and will use `ARG2 = 10`.

```{r}
triple <- function(x) {
y <- x*3
return(y)
}
```

```{r}
x <- 4
triple(x)
```

**Practice:** Create a function "mySquare" that takes two numeric arguments as input, takes the square of the first one, and then adds the second one to it. Set the second argument to take the value 2 as default. Test it. 
```{r}
#write your answer here
```


**Practice:** Create a function "myMean" that takes the mean of a vector of numbers V. 
```{r}
#write your answer here
```

Compare your function to R's inbuilt `mean()` function: (uncomment #myMean() when ready)
```{r}
V <- c(2, 5, 1, 7, 2, 3, 0)
mean(V)
#myMean(V)
```

